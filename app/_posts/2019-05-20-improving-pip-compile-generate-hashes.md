---
title: Improving pip-compile --generate-hashes
author: jack-cushman
excerpt_separator: <!--more-->
---
Recently I landed a series of contributions to the Python package `pip-tools`:

* [Support URLs as packages #807](https://github.com/jazzband/pip-tools/pull/807)
* [Fix --generate-hashes with bare VCS URLs #812](https://github.com/jazzband/pip-tools/pull/812)
* [Fix pip-compile output for unsafe requirements #813](https://github.com/jazzband/pip-tools/pull/813)
* [Warn when --generate-hashes output is uninstallable #814](https://github.com/jazzband/pip-tools/pull/814)

<!--more-->

[pip-tools](https://github.com/jazzband/pip-tools) is a "set of command line tools to help you keep your pip-based [Python] packages fresh, even when you've pinned them." My changes help the `pip-compile --generate-hashes` command work for more people.

This isn't a lot of code in the grand scheme of things, but it's the largest set of contributions I've made to a mainstream open source project, so this blog post is a celebration of me! 🎁💥🎉 yay. But it's also a chance to talk about package manager security and open source contributions and stuff like that.

I'll start high-level with "what are package managers" and work my way into the weeds, so feel free to jump in wherever you want.

## What are package managers?

Package managers help us install software libraries and keep them up to date. If I want to load a URL and print the contents, I can add a dependency on a package like `requests` ...

{% highlight shell %}
$ echo 'requests' > requirements.txt
$ pip install -r requirements.txt
Collecting requests (from -r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/8f/ea/140f18072bbcd81885a9490abb171792fd2961fd7f366be58396f4c6d634/requests-2.0.1-py2.py3-none-any.whl (439kB)
     |████████████████████████████████| 440kB 4.1MB/s
Installing collected packages: requests
Successfully installed requests-2.0.1
{% endhighlight %}

... and let `requests` do the heavy lifting:

{% highlight python %}
>>> import requests
>>> requests.get('http://example.com').text
'<!doctype html>\n<html>\n<head>\n    <title>Example Domain</title> ...'
{% endhighlight %}

But there's a problem -- if I install exactly the same package later, I might get a different result:

{% highlight shell %}
$ echo 'requests' > requirements.txt
$ pip install -r requirements.txt
Collecting requests (from -r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/51/bd/23c926cd341ea6b7dd0b2a00aba99ae0f828be89d72b2190f27c11d4b7fb/requests-2.22.0-py2.py3-none-any.whl (57kB)
     |████████████████████████████████| 61kB 3.3MB/s
Collecting certifi>=2017.4.17 (from requests->-r requirements.txt (line 1))
  Using cached https://files.pythonhosted.org/packages/60/75/f692a584e85b7eaba0e03827b3d51f45f571c2e793dd731e598828d380aa/certifi-2019.3.9-py2.py3-none-any.whl
Collecting urllib3!=1.25.0,!=1.25.1,<1.26,>=1.21.1 (from requests->-r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/39/ec/d93dfc69617a028915df914339ef66936ea976ef24fa62940fd86ba0326e/urllib3-1.25.2-py2.py3-none-any.whl (150kB)
     |████████████████████████████████| 153kB 10.6MB/s
Collecting idna<2.9,>=2.5 (from requests->-r requirements.txt (line 1))
  Using cached https://files.pythonhosted.org/packages/14/2c/cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9/idna-2.8-py2.py3-none-any.whl
Collecting chardet<3.1.0,>=3.0.2 (from requests->-r requirements.txt (line 1))
  Using cached https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl
Installing collected packages: certifi, urllib3, idna, chardet, requests
Successfully installed certifi-2019.3.9 chardet-3.0.4 idna-2.8 requests-2.22.0 urllib3-1.25.2
<requirements.txt, pip install -r, import requests>
{% endhighlight %}

I got a different version of `requests` than last time, and I got some bonus dependencies (`certifi`, `urllib3`, `idna`, and `chardet`). Now my code might not do the same thing even though *I* did the same thing, which is not how anyone wants computers to work. (I've cheated a little bit here by showing the first example as though `pip install` had been run back in 2013.)

So the next step is to pin the versions of my dependencies and their dependencies, using a package like `pip-tools`:

{% highlight shell %}
$ echo 'requests' > requirements.in
$ pip-compile
$ cat requirements.txt
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile
#
certifi==2019.3.9         # via requests
chardet==3.0.4            # via requests
idna==2.8                 # via requests
requests==2.22.0
urllib3==1.25.2           # via requests
{% endhighlight %}

(There are other options I could use instead, like `pipenv` or `poetry`. For now I still prefer pip-tools, for roughly [the reasons laid out by Hynek Schlawack](https://hynek.me/articles/python-app-deps-2018/).)

Now when I run `pip install -r requirements.txt` I will always get the same version of requests, and the same versions of its dependencies, and my program will always do the same thing.

... just kidding.

## The problem with pinning Python packages

Unfortunately `pip-compile` doesn't quite lock down our dependencies the way we would hope! In Python land you don't necessarily get the same version of a package by asking for the same version number. That's because of binary wheels.

Up until 2015, it was possible to change a package's contents on PyPI without changing the version number, [simply by deleting the package and reuploading it](https://mail.python.org/pipermail/distutils-sig/2015-January/025683.html). That no longer works, but there is still a loophole: you can delete and reupload binary wheels.

[Wheels](https://pythonwheels.com/) are a new-ish binary format for distributing Python packages, including any precompiled programs written in C (or other languages) used by the package. They speed up installs and avoid the need for users to have the right compiler environment set up for each package. C-based packages typically offer a bunch of wheel files for different target environments -- here's [bcrypt's wheel files for example](https://pypi.org/project/bcrypt/#files).

So what happens if a package was originally released as source, and then the maintainer wants to add binary wheels for the same release years later? PyPI will allow it, and pip will happily install the new binary files. This is a [deliberate design decision](https://github.com/pypa/packaging-problems/issues/75#issuecomment-347739479): PyPI has "made the deliberate choice to allow wheel files to be added to old releases, though, and advise folks to use --no-binary and build their own wheel files from source if that is a concern."

That creates room for weird situations, like this case where [wheel files were uploaded](https://pypi.org/project/hiredis/0.2.0/#files) for the `hiredis` 0.2.0 package on August 16, 2018, three years after the source release on April 3, 2015. The package had been handed over without announcement from Jan-Erik Rediger to a new volunteer maintainer, ifduyue, who uploaded the binary wheels. ifduyue's personal information on Github consists of: a new moon emoji; an upside down face emoji; the location "China"; and an image of Lanny from the show *Lizzie McGuire* with spirals for eyes. [In a bug thread opened after ifduyue uploaded the new version of hiredis 0.2.0](https://github.com/redis/hiredis-py/issues/69), Jan-Erik commented that users should "please double-check that the content is valid and matches the repository."

![ifduyue's user account on github.com](https://lil-blog-media.s3.amazonaws.com/Screen_Shot_2019-05-17_at_5.21.54_PM.png)

The problem is that I can't do that, and most programmers can't do that. We can't just rebuild the wheel ourselves and expect it to match, because builds are not reproducible unless one [goes to great lengths like Debian does](https://wiki.debian.org/ReproducibleBuilds/PythonWheelPackage). So verifying the integrity of an unknown binary wheel requires rebuilding the wheel, comparing a diff, and checking that all discrepancies are benign -- a time-consuming and error-prone process even for those with the skills to do it.

So the story of `hiredis` looks a lot like a new open source developer volunteering to help out on a project and picking off some low-hanging fruit in the bug tracker, but it also looks a lot like an attacker using the perfect technique to distribute malware widely in the Python ecosystem without detection. I don't know which one it is! As a situation it's bad for us as users, and it's not fair to ifduyue if in fact they're a friendly newbie contributing to a project.

(Is the hacking paranoia warranted? I think so! As [Dominic Tarr wrote](https://gist.github.com/dominictarr/9fd9c1024c94592bc7268d36b8d83b3a) after inadvertently handing over control of an npm package to a bitcoin-stealing operation, "I've shared publish rights with other people before. ... open source is driven by sharing! It's great! it worked really well before bitcoin got popular.")

This is a big problem with a lot of dimensions. It would be great if PyPI packages were all fully reproducible and checked to verify correctness. It would be great if PyPI didn't let you change package contents after the fact. It would be great if everyone ran their own private package index and only added packages to it that they had personally built from source that they personally checked, the way big companies do it. But in the meantime, we can bite off a little piece of the problem by adding hashes to our requirements file. Let's see how that works.

## Adding hashes to our requirements file

Instead of just pinning packages like we did before, let's try adding hashes to them:

{% highlight shell %}
$ echo 'requests==2.0.1' > requirements.in
$ pip-compile --generate-hashes
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --generate-hashes
#
requests==2.0.1 \
    --hash=sha256:8cfddb97667c2a9edaf28b506d2479f1b8dc0631cbdcd0ea8c8864def59c698b \
    --hash=sha256:f4ebc402e0ea5a87a3d42e300b76c292612d8467024f45f9858a8768f9fb6f6e
{% endhighlight %}

Now when pip-compile pins our package versions, it also fetches the currently-known hashes for each requirement and adds them to requirements.txt (an example of the crypto technique of "TOFU" or "Trust On First Use"). If someone later comes along and adds new packages, or if the https connection to PyPI is later insecure for whatever reason, pip will refuse to install and will warn us about the problem:

{% highlight shell %}
$ pip install -r requirements.txt
...
ERROR: THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE. If you have updated the package versions, please update the hashes. Otherwise, examine the package contents carefully; someone may have tampered with them.
    requests==2.0.1 from https://files.pythonhosted.org/packages/8f/ea/140f18072bbcd81885a9490abb171792fd2961fd7f366be58396f4c6d634/requests-2.0.1-py2.py3-none-any.whl#sha256=f4ebc402e0ea5a87a3d42e300b76c292612d8467024f45f9858a8768f9fb6f6e (from -r requirements.txt (line 7)):
        Expected sha256 8cfddb97667c2a9edaf28b506d2479f1b8dc0631cbdcd0ea8c8864def59c6981
        Expected     or f4ebc402e0ea5a87a3d42e300b76c292612d8467024f45f9858a8768f9fb6f61
             Got        f4ebc402e0ea5a87a3d42e300b76c292612d8467024f45f9858a8768f9fb6f6e
{% endhighlight %}

But there are problems lurking here! If we have packages that are installed from Github, then pip-compile can't hash them and pip won't install them:

{% highlight shell %}
$ echo '-e git+https://github.com/requests/requests@master#egg=requests' > requirements.in
$ pip-compile --generate-hashes
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --generate-hashes
#
-e git+https://github.com/requests/requests@master#egg=requests
certifi==2019.3.9 \
    --hash=sha256:59b7658e26ca9c7339e00f8f4636cdfe59d34fa37b9b04f6f9e9926b3cece1a5 \
    --hash=sha256:b26104d6835d1f5e49452a26eb2ff87fe7090b89dfcaee5ea2212697e1e1d7ae
chardet==3.0.4 \
    --hash=sha256:84ab92ed1c4d4f16916e05906b6b75a6c0fb5db821cc65e70cbd64a3e2a5eaae \
    --hash=sha256:fc323ffcaeaed0e0a02bf4d117757b98aed530d9ed4531e3e15460124c106691
idna==2.8 \
    --hash=sha256:c357b3f628cf53ae2c4c05627ecc484553142ca23264e593d327bcde5e9c3407 \
    --hash=sha256:ea8b7f6188e6fa117537c3df7da9fc686d485087abf6ac197f9c46432f7e4a3c
urllib3==1.25.2 \
    --hash=sha256:a53063d8b9210a7bdec15e7b272776b9d42b2fd6816401a0d43006ad2f9902db \
    --hash=sha256:d363e3607d8de0c220d31950a8f38b18d5ba7c0830facd71a1c6b1036b7ce06c
$ pip install -r requirements.txt
Obtaining requests from git+https://github.com/requests/requests@master#egg=requests (from -r requirements.txt (line 7))
ERROR: The editable requirement requests from git+https://github.com/requests/requests@master#egg=requests (from -r requirements.txt (line 7)) cannot be installed when requiring hashes, because there is no single file to hash.
{% endhighlight %}

That's a serious limitation, because `-e` requirements are the only way `pip-tools` knows to specify installations from version control, which are useful while you wait for new fixes in dependencies to be released. (We mostly use them at LIL for dependencies that we've patched ourselves, after we send fixes upstream but before they are released.)

And if we have packages that rely on dependencies `pip-tools` considers unsafe to pin, like `setuptools`, pip will refuse to install those too:

{% highlight shell %}
$ echo 'Markdown' > requirements.in
$ pip-compile --generate-hashes
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --generate-hashes
#
markdown==3.1 \
    --hash=sha256:fc4a6f69a656b8d858d7503bda633f4dd63c2d70cf80abdc6eafa64c4ae8c250 \
    --hash=sha256:fe463ff51e679377e3624984c829022e2cfb3be5518726b06f608a07a3aad680
$ pip install -r requirements.txt
Collecting markdown==3.1 (from -r requirements.txt (line 7))
  Using cached https://files.pythonhosted.org/packages/f5/e4/d8c18f2555add57ff21bf25af36d827145896a07607486cc79a2aea641af/Markdown-3.1-py2.py3-none-any.whl
Collecting setuptools>=36 (from markdown==3.1->-r requirements.txt (line 7))
ERROR: In --require-hashes mode, all requirements must have their versions pinned with ==. These do not:
    setuptools>=36 from https://files.pythonhosted.org/packages/ec/51/f45cea425fd5cb0b0380f5b0f048ebc1da5b417e48d304838c02d6288a1e/setuptools-41.0.1-py2.py3-none-any.whl#sha256=c7769ce668c7a333d84e17fe8b524b1c45e7ee9f7908ad0a73e1eda7e6a5aebf (from markdown==3.1->-r requirements.txt (line 7))
{% endhighlight %}

This can be worked around by adding `--allow-unsafe`, but (a) that sounds unsafe (though it isn't), and (b) it won't pop up until you try to set up a new environment with a low version of `setuptools`, potentially days later on someone else's machine.

## Fixing pip-tools

Those two problems meant that, when I set out to convert our [Caselaw Access Project code](https://github.com/harvard-lil/capstone) to use `--generate-hashes`, I did it wrong a few times in a row, leading to multiple hours spent debugging problems I created for me and other team members (sorry, Anastasia!). I ended up needing a fancy wrapper script around `pip-compile` to rewrite our requirements in a form it could understand. I wanted it to be a smoother experience for the next people who try to secure their Python projects.

So I filed a series of pull requests:

### Support URLs as packages

[Support URLs as packages #807](https://github.com/jazzband/pip-tools/pull/807) and [Fix --generate-hashes with bare VCS URLs #812](https://github.com/jazzband/pip-tools/pull/812) laid the groundwork for fixing `--generate-hashes`, by teaching `pip-tools` to do something that had been requested for years: installing packages from archive URLs. Where before, pip-compile could only handle Github requirements like this:

	-e git+https://github.com/requests/requests@master#egg=requests
	 
It can now handle requirements like this:

	https://github.com/requests/requests/archive/master.zip
		
And zipped requirements can be hashed, so the resulting requirements.txt comes out looking like this, and is accepted by `pip install`:

	https://github.com/requests/requests/archive/master.zip \
   	     --hash=sha256:3c3d84d35630808bf7750b0368b2c7988f89d9f5c2f2633c47f075b3d5015638
		
This was a long process, and began with resurrecting [a pull request from 2017](https://github.com/jazzband/pip-tools/issues/272) that had first been worked on by nim65s. I started by just rebasing the existing work, fixing some tests, and submitting it in the hopes the problem had already been solved. Thanks to great feedback from auvipy, atugushev, and blueyed, I ended up making 14 more commits (and eventually a follow-up pull request) to clean up edge cases and get everything working.

Landing this resulted in closing two other `pip-tools` pull requests from 2016 and 2017, and feature requests from 2014 and 2018.

### Warn when `--generate-hashes` output is uninstallable

The next step was [Fix pip-compile output for unsafe requirements #813](https://github.com/jazzband/pip-tools/pull/813) and [Warn when --generate-hashes output is uninstallable #814](https://github.com/jazzband/pip-tools/pull/814). These two PRs allowed `pip-compile --generate-hashes` to detect and warn when a file would be uninstallable for hashing reasons. Fortunately `pip-compile` has all of the information it needs at compile time to know that the file will be uninstallable and to make useful recommendations for what to do about it:

{% highlight shell %}
$ pip-compile --generate-hashes
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --generate-hashes
#
# WARNING: pip install will require the following package to be hashed.
# Consider using a hashable URL like https://github.com/jazzband/pip-tools/archive/SOMECOMMIT.zip
-e git+https://github.com/jazzband/pip-tools@7d86c8d3ecd1faa6be11c7ddc6b29a30ffd1dae3#egg=pip-tools
click==7.0 \
    --hash=sha256:2335065e6395b9e67ca716de5f7526736bfa6ceead690adf616d925bdc622b13 \
    --hash=sha256:5b94b49521f6456670fdb30cd82a4eca9412788a93fa6dd6df72c94d5a8ff2d7
first==2.0.2 \
    --hash=sha256:8d8e46e115ea8ac652c76123c0865e3ff18372aef6f03c22809ceefcea9dec86 \
    --hash=sha256:ff285b08c55f8c97ce4ea7012743af2495c9f1291785f163722bd36f6af6d3bf
markdown==3.1 \
    --hash=sha256:fc4a6f69a656b8d858d7503bda633f4dd63c2d70cf80abdc6eafa64c4ae8c250 \
    --hash=sha256:fe463ff51e679377e3624984c829022e2cfb3be5518726b06f608a07a3aad680
six==1.12.0 \
    --hash=sha256:3350809f0555b11f552448330d0b52d5f24c91a322ea4a15ef22629740f3761c \
    --hash=sha256:d16a0141ec1a18405cd4ce8b4613101da75da0e9a7aec5bdd4fa804d0e0eba73

# WARNING: The following packages were not pinned, but pip requires them to be
# pinned when the requirements file includes hashes. Consider using the --allow-unsafe flag.
# setuptools==41.0.1        # via markdown
{% endhighlight %}
	
Hopefully, between these two efforts, the next project to try using --generate-hashes will find it a shorter and more straightforward process than I did!

## Things left undone

Along the way I discovered a few issues that could be fixed in various projects to help the situation. Here are some pointers:

First, the warning to use `--allow-unsafe` seems unnecessary -- I believe that `--allow-unsafe` should be the default behavior for pip-compile. I spent some time digging into the reasons that pip-tools considers some packages "unsafe," and as best I can tell it is because it was thought that pinning those packages could potentially break pip itself, and thus break the user's ability to recover from a mistake. This seems to no longer be true, if it ever was. Instead, *failing to use --allow-unsafe* is unsafe, as it means different environments will end up with different versions of key packages despite installing from identical requirements.txt files. I started some discussion about that on the [pip-tools repo](https://github.com/jazzband/pip-tools/issues/806) and the [pip repo](https://github.com/pypa/pip/issues/6459).

Second, the warning not to use version control links with `--generate-hashes` is necessary only because of pip's decision to refuse to install those links alongside hashed requirements. That seems like a bad security tradeoff for several reasons. I filed [a bug with pip](https://github.com/pypa/pip/issues/6469) to open up discussion on the topic.

Third, PyPI and binary wheels. I'm not sure if there's been further discussion on the decision to allow retrospective binary uploads since 2017, but the example of hiredis makes it seem like that has some major downsides and might be worth reconsidering. I haven't yet filed anything for this.

## Personal reflections (and, thanks Jazzband!)

I didn't write a ton of code for this in the end, but it was a big step for me personally in working with a mainstream open source project, and I had a lot of fun -- learning tools like `black` and git multi-author commits that we don't use on our own projects at LIL, collaborating with highly responsive and helpful reviewers (thanks, all!), learning the internals of pip-tools, and hopefully putting something out there that will make people more secure.

`pip-tools` is part of the [Jazzband project](https://jazzband.co/), which is an interesting attempt to make the Python package ecosystem a little more sustainable by lowering the bar to maintaining popular packages. I had a great experience with the maintainers working on `pip-tools` in particular, and I'm grateful for the work that's gone into making Jazzband happen in general.
